1、Overload和Override的区别?
	答：Overload：重载
			是一个类中的多态性 让类以统一的方式处理不同的数据类型的一种手段，多个同名函数同时存在，
具有不同的参数个数（类型）
			方法名相同 参数类型与返回类型相同也可以不同.  
		Override：重写
			父类与子类之间的多态性，对父类的函数进行重新定义。
			与父类有相同的方法名，参数和返回类型
		
2、String 和StringBuffer和 StringBuilder的区别?
	答：String 是常量 不可改变长度 返回会生成一个新的字符串
		StringBuffer 是变量 可改变长度  不会返回一个新的字符串  线程安全
		StringBuilder 是后来引入的 线程不安全 在单线程中比StringBuffer 性能高
		
3、实现一个字符串倒序?
	答：reverse()方法实现字符串倒序
		例：String a = "abcd";  
			StringBuffer sb = new StringBuffer(a);  
			a = sb.reverse().toString();  
			System.out.println(a);  
			
4、集合的实现类与区别?
	答：collection:
			set(无序集合，元素不可重复):
				HashSet: 
					底层：哈希表
					优点：允许使用null对象，无序唯一存取查找快
					缺点：不同步，元素可以是null,但只能放一个null,线程不安全
				TreeSet:
					底层：红黑树
					优点：有顺序，自定义的对象需要实现Comparable接口的compare
					缺点：线程不安全
			list(有序集合，元素可重复):
				ArrayList:
					可变数组
					优点：可保存所有元素，包括Null 查询快
					缺点：增删慢，没有同步
				LinkedList:
					链表结构，常用于堆栈与队列的实现
					优点：增删快
					缺点：查询慢
				vector:
					数组实现重量级
					优点：线程安全，可以同步
					缺点：运行慢
		Map(不能包含重复的Key,但是可以包含相同的value):
			HashMap:
				基于哈希表的Map接口实现，提供所有可选的映射操作，允许使用null值和null键，保证键的唯一性
				优点：查询快
				缺点：不保证顺序
			TreeMap:
				底层：红黑树
				优点：有顺序
				缺点：不允许键对象是null
	
5、抽象类与接口的区别（abstract与interface的区别）?
	答：1，抽象类里可以有构造方法，而接口内不能有构造方法。
		2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。
		3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。
		4，抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
		5，抽象类中可以包含静态方法，接口内不能包含静态方法。
		6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public  static类型，并且默认为public static类型。
		7，一个类可以实现多个接口，但只能继承一个抽象类。
		接口更多的是在系统框架设计方法发挥作用，主要定义模块之间的通信，而抽象类在代码实现方面发挥作用，可以实现代码的重用
	
6、线程有几种状态,分别是哪些?
	答：新建 ——>就绪 ———>运行 ——>阻塞 ——>死亡
	
7、final、finally、finanlize()的区别?
	答：final：最终的意思，被final修饰过的变量不可被改变，修饰过的方法不可被重写，修饰过的类不可被继承
		finally：在try(){}catch(){}finally(){} 来执行任何清除操作
				 有一个执行细节：如果在try或者catch语句内有return语句。return语句在finally语句执行结束后才执行，但finally并不能改变返回值
		finanlize()：垃圾回收  由垃圾收集器在确定这个对象没有被引用时对这个对象调用
	
8、J2EE是什么？请对以下在J2EE中常用的名词进行解释(或简单描述)?
	答：1.Je22 是Sun 公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model)
		  所属层次包括客户层(clietn tier)组件,web 层和组件,Business 层和组件,企业信息系统(EIS)层
		  j2ee 就是增删改查
		2.web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量交互，不必关注其它系统问题
		  EJB容器:Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务
		  JNDI:JAVA命名目录服务
		  JMS:JAVA消息服务
		  JTA:JAVA事务服务
		  JAF:JAVA安全认证框架
		  RMI/IIOP:主要用于通过远程调用服务
		

9、J2EE常用的设计模式？说明工厂模式?
	答：工厂模式：
			在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
			定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
			优点：1、一个调用者想创建一个对象，只要知道其名称就可以了。 
				  2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
				  3、屏蔽产品的具体实现，调用者只关心产品的接口。
			缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。
		单例模式
		适配器模式
		观察者模式

10、开发中都用到了那些设计模式?用在什么场合?
	Java中的23种设计模式： 
Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式）， 
Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式）， 
Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式）， 
Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式）， 
Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式）， 
Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式）， 
Observer（观察者模式），   State（状态模式），         Strategy（策略模式）， 
Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）

11、什么是面向对象以及与面向过程的区别？
	答：面向对象：
			以事物中心为核心
		面向过程：
			以事物发展过程为核心
		就是说 由代码的执行者变成了指挥者
		
12、面向对象的三大特性、五大原则？
	答：封装、继承、多态
		单一模式、开放封闭原则、依赖倒置原则、里氏替换原则、接口分离原则
		
13、对封装、继承、多态的理解？
	答：封装：有封装就有暴露，封装属性和方法   使其减少耦合性，可以对对象的数据类型进行修改
		继承：就是自定义类继承父类，子类可以实现父类中的一些方法，也可以在子类中写我们所需的方法
			  单继承多实现  提高了代码的复用性
		多态：可以说是方法的重载和重写
			  Overload：重载
				是一个类中的多态性 让类以统一的方式处理不同的数据类型的一种手段，多个同名函数同时存在，具有不同的参数个数（类型）
				方法名相同 参数类型与返回类型相同也可以不同.  
			  Override：重写
				父类与子类之间的多态性，对父类的函数进行重新定义。
				与父类有相同的方法名，参数和返回类型
	
14、Java的排序方式？
	答：冒泡排序
		选择排序
		快速排序
		插入排序
		
15、Java内存模型是什么？
	答：规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性的行为
		程序次序规则：线程中的代码能够按先后顺序执行
		管程锁定规则：对于同一个锁，一个解锁操作一定要发生在另一个锁定操作之前
		volatile变量规则：前一个对volatile的写操作在后一个volatile的读操作之前
		线程启动规则：一个线程内的任何操作必须在这个线程的start()调用之后
		线程终止规则：一个线程的所有操作都会在线程终止之前
		对象终结规则：一个对象的终结操作必需在这个对象构造完成之后
		可传递性
		
16、Thread 类中的start() 和 run() 方法有什么区别？
	答：start()是用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()效果不一样
		调用run()的时候，只会在原来的线程中调用，没有新的线程启动，start()才会启动新线程
	
17、Java的引用类型有哪些？
	答：强引用 软引用 弱引用 虚引用
	
18、标识符组成规则?
	答：就是给类，接口，方法，变量等起名字时使用的字符序列
		由字母，数组，下划线，$组成
			数字不能开头
			不能使用关键字
			区分大小
			命名规范，见名知意
		类名(首字母大写) 
		方法名和变量名(首字母小写从第二个字母开始每个单词的首字母大写)
		常量(全部大写)
		包(全部小写)
	
19、单&和双&的区别?
	答：&：不管前面是否为flase，后面都参与运算
		&&：前面可以得到结果，后面不运算
	
20、单|和双|的区别?
	答：|：不管前面是否为true,后面都参与运算
		||：前面可以得到结果，后面不参与运算
	
	
21、==和equals的区别?
	答：==：比较的是地址值
		equals：比较的是内容

22、UDP 和TCP分别是什么及其区别?
	答：UDP:数据打包，有限制(64k)，不连接服务器，效率高，不可靠
		TCP:建立数据通道，需要三次握手，无限制，效率低，可靠

23、List、ArrayList、LinkedList底层分别什么实现的?
	答：List：实现Collection接口
		ArrayList:底层数据结构使数组结构，查询速度快，增删改慢
		LinkedList:底层使用链表结构，增删速度快，查询稍慢

24、Get和post区别?
	答:get:地址栏会携带提交数据，安全级别低，有数据大小限制(2k)，建议在数据查询时使用
	   post：把数据带到请求体里，安全级别高，没有大小限制，建议在数据添加修改时使用
	

25、网络通信三要素分别是什么及其作用?
	答：IP： InetAddress
		端口： 应用程序的标识  0-65535之间
		协议：UDP与TCP

26、简述如何的实现多线程?
	答：裸线程
		Executors创建线程池
		ForkJoinPool fork/join(分叉/结合)并发框架
		Actor模型

27、说出Servlet的生命周期，并说出Servlet和CGI的区别?
	答：Servlet的生命周期分为5个阶段:
			实例化：Servlet容器创建Servlet类的实例。
			初始化：该容器调用init()方法，通常会申请资源。
			服务：由容器调用service()方法，（也就是doGet()和doPost()）。
			破坏：在释放Servlet实例之前调用destroy()方法，通常会释放资源。
			不可用：释放内存的实例。
		CGI（Common Gateway Interface通用网关接口）程序来实现数据在Web上的传输，使用的是如Perl这样的语言编写的，它对于客户端作出的每个请求，
		必须创建CGI程序的一个新实例，这样占用大量的内存资源。由此才引入了Servlet技术。
		Servlet是一个用java编写的应用程序，在服务器上运行，处理请求信息并将其发送到客户端。对于客户端的请求，只需要创建Servlet的实例一次，
		因此节省了大量的内存资源。Servlet在初始化后就保留在内存中，因此每次作出请求时无需加载。

28、同步和异步有何异同，在什么情况下分别使用他们？举例说明?
	答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
		当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率
		同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；           银行的转账系统，对数据库的保存操作等等
		异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。         其余情况都优先使用异步交互
		区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式
	
29、heap和stack有什么区别?
	答：heap(堆):可以动态地分配内存大小  用来存放由new创建的对象和数组
		stack(栈):存取速度比堆要快   存在栈中的数据可以共享
		字面值的引用与类对象的引用不同

30、forward和redirect的区别?
	答：forward(转发):
			1.是服务器内部的重定向，服务器直接访问目标地址的 url网址，把里面的东西读取出来，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。 
			2.关于request: 由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者servlet中使用。
		redirect(重定向):
			1.是客户端的重定向，是完全的跳转。即服务器返回的一个url给客户端浏览器，然后客户端浏览器会重新发送一次请求，到新的url里面，因此浏览器中显示的url网址会发生变化。 
			2.因为这种方式比forward多了一次网络请求，因此效率会低于forward。

31、说出数据连接池的工作机制是什么 ?
	答：J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。
		如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。

32、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢 ?
	答：==是用来判断两者是否是同一对象(同一事物),而equals是用来判断是否引用同一个对象.再看一下Set里面存的是对象,还是对象的引用.根据java的存储机制可知，set里面存放的是对象的引用，所以当两个元素只要满足了equals()时就已经指向同一个对象，也就出现了重复元素。所以应该用equals()来判断
  
32、两个对象值相同(x.equals(y) == true)?
	答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同
		1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；
		2)如果两个对象的hashCode相同，它们并不一定相同。 

33、重写equals()方法的时候，我们还需要重写哪个方法？为什么?
	答：hashcode()方法
		因为:先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，而equals()方法判断出来的结果为true。
			 在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。
			 这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题

34、当一个对象被当作参数传递到一个方法后?
	答:
	
35、java中有几种方法可以实现一个线程?
	答:继承Thread  实现Runnable接口  ExecutorService实现线程池

36、java 是如何分配内存的 ， java的内存管理  ？ 
	答:Java的内存管理就是对象的分配和释放问题。
	   分配 ：内存的分配是由程序完成的，程序员需要通过关键字new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。
	   释放 ：对象的释放是由垃圾回收机制决定和执行的，这样做确实简化了程序员的工作。但同时，它也加重了JVM的工作。因为，GC为了能够正确释放对象，GC必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。

37、线程池的理解?
	答：线程是轻量级的进程，是程序执行任务的最小单位，有主线程与子线程
		多线程：出现提高了我们的工作效率，但是必须要注意一些问题，线程的同步问题，当我们多个线程同时访问同一个资源时，很容易出现线程安全问题
		线程池： 是一种多线程处理形式，处理过程中将任务添加到队列，然后创建线程后自动启动这些任务
				 好处：能减少线程多次创建和销会带来的性能开销
					   可以控制线程的最大并发数
				四个组成部分：线程池管理池：负责创建线程池销会 添加新任务
							  工作线程：线程池中的线程，在没有任务时会等待，可以循环的执行任务
							  任务接口：每个任务必须实现的接口，让线程调度任务执行，规定入口，收尾任务的执行状态
							  任务队列：存放没有处理的任务，缓冲区
				四个线程池：可缓存的线程池  创建一定长的线程池(控制线程最大并发数)  也是一个定长的线程池(延时执行  循环执行)  一个单线程话的线程池
		子线程

38、HashMap和LinkedHashMap的区别?
	答：HashMap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。
	　　HashMap最多只允许一条记录的键为Null；允许多条记录的值为 Null。
	　　HashMap不支持线程的同步
		
		LinkedHashMap:保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时带参数，按照应用次数排序。
		速度慢：在遍历的时候会比HashMap慢，不过有种情况例外：当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢。因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关

40、Error和Exception有什么区别？
	Exception：
		1．可以是可被控制(checked) 或不可控制的(unchecked)。
		2．表示一个由程序员导致的错误。
		3．应该在应用程序级被处理。
	Error：
	1．总是不可控制的(unchecked)。
	2．经常用来用于表示系统错误或低层资源的错误。
	3．如何可能的话，应该在系统级被捕捉。	

41、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？
	答：try块表示程序正常的业务执行代码。如果程序在执行try块的代码时出现了“非预期”情况，JVM将会生成一个异常对象，这个异常对象将会被后面相应的catch块捕获。
		catch块表示一个异常捕获块。当程序执行try块引发异常时，这个异常对象将会被后面相应的catch块捕获。
		throw用于手动地抛出异常对象。throw后面需要一个异常对象。
		throws用于在方法签名中声明抛出一个或多个异常类，throws关键字后可以紧跟一个或多个异常类。
		finally块代表异常处理流程中总会执行的代码块。

42、运行时异常与受检异常有何异同？
	答：异常（Exception）：你可以使用运行时异常或者编译时异常。 
		运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。
		一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常。 
		
		受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。

43、Collection和Collections的区别？
	答：java.util.Collection 是一个集合接口。 
		它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。
		以下接口实现了Collection接口： map，set，list，vector
		java.util.Collections 是一个包装类。 
		它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。
		

44、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?
	答：sleep():仅仅释放cpu资源或者让当前线程停止执行一段时间，但不会释放锁；
				会指定睡眠时间自动唤醒，不释放同步锁，需要捕捉异常
		wait():用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁
				没有其他线程唤醒，就不会重新启动，释放锁，不需要捕捉异常

45、线程的sleep()方法和yield()方法有什么区别？
	答：sleep():在其他线程运行时不会考虑线程的优先级，执行方法时会进入阻塞状态，声明抛出InterruptedException
		yield():只会给相同优先级或更高优先级的线程以运行的机会，执行方法时会进入就绪状态，不声明任何异常

46、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？
	答:不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，
		如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

47、请说出与线程同步以及线程调度相关的方法?
	答:wait():使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
	   sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； 
	   notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
	   notityAll():唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；

48、synchronized关键字的用法？
	答:同步方法:synchronized关键字可用于方法的声明中，用于同步某个方法，加了synchronized关键字的方法相当于一个临界区，同一个对象的同一个synchronized方法同一时间只允许一个线程访问。
	   同步代码块:同步代码块，也就是让一段代码成为临界区而不是整个方法。对于同一个Object（对象）代码块只能被一个线程访问。
	   同步对象:最终是防止多个线程调用同一个对象的方法或者代码段
		

49、启动一个线程是调用run()还是start()方法？	
	答:start()方法
	   run()是调用线程中的一个方法
	   start()是开启一个线程

50、简述synchronized 和java.util.concurrent.locks.Lock的异同？
	答：主要相同点：Lock能完成synchronized所实现的所有功能
		主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。

51、Java中如何实现序列化，有什么意义？
	答：1.实现序列化:
			1)让类实现Serializable接口,该接口是一个标志性接口,标注该类对象是可被序列
			2)然后使用一个输出流来构造一个对象输出流并通过writeObect(Obejct)方法就可以将实现对象写出
			3)如果需要反序列化,则可以用一个输入流建立对象输入流,然后通过readObeject方法从流中读取对象
		2.作用:
			1)序列化就是一种用来处理对象流的机制,所谓对象流也就是将对象的内容进行流化,可以对流化后的对象进行读写操作,也可以将流化后的对象传输与网络之间;
			2)为了解决对象流读写操作时可能引发的问题(如果不进行序列化,可能会存在数据乱序的问题)
			3）序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆

52、可传递性有三个线程T1，T2，T3，怎么确保它们按顺序执行？
	答：先执行T3 从T3调用T2，T2调用T1，T1调用T3
		用线程类的join()方法在一个线程中启动另一个线程,另一个线程完成    用join()方法调用T3

53、网络数据的三次握手 Socket 的理解 ？
	答:

54、Socket是如何建立连接的并进行数据传递的？

55、为什么说https协议是安全的？

56、什么是分布式垃圾回收(DGC)？它是如何工作的？

57、什么是形参和实参?

58、抽象类、抽象方法、抽象类的特点?

59、LinkedList 集合 、LinkedList特点?

60、异常：编译时异常，运行时异常的处理方法?

61、饿汉式和懒汉式的区别?

62、Session是什么，用来干什么的，解决什么问题?

63、C/S和B/S结构?
	B/S架构的全称为Browser/Server，即浏览器/服务器结构。（例如百度，谷歌等）

	B/S架构的优缺点?

	优点：?
	1）客户端无需安装，有Web浏览器即可。?

	2）BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。
	?
	3）BS架构无需升级多个客户端，升级服务器即可。?


	缺点：
	?
	1）在跨浏览器上，BS架构不尽如人意。
	?
	2）表现要达到CS程序的程度需要花费不少精力。?

	3）在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。?
	4）客户端服务器端的交互是请求-响应模式，通常需要刷新页面，这并不是客户乐意看到的。（在Ajax风行后此问题得到了一定程度的缓解）?


	C/S 架构是一种典型的两层架构，其全程是Client/Server，即客户端服务器端架构 常见QQ飞秋等。
	C/S 架构的优缺点?

	优点：?
	1.C/S架构的界面和操作可以很丰富。
	?
	2.安全性能可以很容易保证，实现多层认证也不难。
	?
	3.由于只有一层交互，因此响应速度较快。?


	缺点：
	?
	1.适用面窄，通常用于局域网中。?

	2.用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户。
	?
	3.维护成本高，发生一次升级，则所有客户端的程序都需要改变。?

64、http和https的区别?
	1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

	2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

	3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

	4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
65、常见的请求头有哪些？

66、即时通讯的实现基于什么协议来实现的？

67、http协议处于网络的哪一层？
		网络有七层：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。
	HTTP协议处于应用层。与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。
	例如，一个没有通信功能的字处理程序就不能执行通信的代码，从事字处理工作的程序员也不关心OSI的第7层。
	但是，如果添加了一个传输文件的选项，那么字处理器的程序员就需要实现OSI的第7层
68、Delete、put、head这些请?
	HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，
	而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。
	想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。

	PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，
	但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定

	DELETE：删除某一个资源。基本上这个也很少见，
	不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源
69、String类的特点？

70、equals()方法和equalsIgnoreCase（）方法的区别？

71、isEmpty()方法的作用？

72、HashSet如何保证元素唯一性?

73、LinkedHashSet类的特点?

74、Iterator 相关方法和注意事项?

75、集合类的特点?
		List接口中，比较常用的类有三个：ArrayList、Vactor、LinkedList。
	 ArrayList ：线程不安全的，对元素的查询速度快。 
	Vector ：线程安全的，多了一种取出元素的方式：枚举（Enumeration），但已被ArrayList取代。 
	LinkedList ：链表结构，对元素的增删速度很快。 
	Set接口中，比较常用的类有两个：HashSet、TreeSet： 
	HashSet:要保证元素唯一性，需要覆盖掉Object中的equals和hashCode方法（因为底层是通过这两个方法来判断两个元素是否是同一个）。   
	TreeSet：以二叉树的结构对元素进行存储，可以对元素进行排序。       
	排序的两种方式：              
	1、元素自身具备比较功能，元素实现Comparable接口，覆盖compareTo方法。           
	2、建立一个比较器对象，该对象实现Comparator接口，覆盖compare方法，并将该对象作为参数传给TreeSet的构造函数（可以用匿名内部类）。   
	Map接口其特点是：元素是成对出现的，以键和值的形式体现出来，键要保证唯一性：常用类有：HashMap，Hashtable ，TreeMap。 
	HashMap：线程不安全等的，允许存放null键null值。 
	Hashtable：线程安全的，不允许存放null键null值。 
	TreeMap：可以对键进行排序（要实现排序方法同TreeSet）。 
	Collection和Map两个接口对元素操作的区别：存入元素： Collection接口下的实现类通过add方法来完成，而Map下是通过put方法来完成。 
	取出元素： Collection接口下：List接口有两种方式：1、get(脚标)；2、通过Iterator迭代方式获取元素；而Vactor多了一种枚举（Enumeration）的方式。Set接口通过迭代的方式获取元素。 Map接口下：先通地keySet获取键的系列，然后通过该系列使用Iterator迭代方式获取元素值。
76、什么是进程？
	进程和线程都是由操作系统所体现的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。
77、I/O流？
       
1、Java 语言中I/O流分类：      
分为输入流(Input Stream) 和输出流(Output Stream)      分为节点流(Node Stream) 和处理流(Processing Stream)      分为字符流(Character Stream) 和字节流(Byte Stream)

78、数组和链表的异同？
       数组的优点随机访问性强 查找速度快 数组的缺点 插入和删除效率低 可能浪费内存 内存空间要求高，必须有足够的连续内存空间。 数组大小固定，不能动态拓展
链表的优点 插入删除速度快 内存利用率高，不会浪费内存 大小没有固定，拓展很灵活。链表的缺点 不能随机查找，必须从第一个开始遍历，查找效率低 、
79、线程和进程有什么区别？

80、如何实现线程?

81、使用多线程的优缺点？

82、怎么判断服务端返回的数据类型?

83、栈，队列代码?
84、多线程下载，离线下载?
85、java常用的处理异常的机制，原理及应用?
86、一段字符串“abdecffr”,请输出只出现一次的字母输入一个数，求其二进数中有多少个1?
88、Java中操作字符串使用哪个类？
89、String类的常用方法有那些？
90、判断两个对象是否相同，能使用equlas比较吗？
91、Java中的继承是单继承还是多继承?
92、super与this表示什么？
93、接口有什么特点？
94、Java中异常分为哪两种？
95、Array与ArrayList有什么不一样？
96、常用io类有那些？
97、线程同步的方法?
98、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
99、static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法?
100、概括的解释下线程的几种可用状态?
101、Java支持的数据类型有哪些？什么是自动拆装箱？
102、Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
103、Java支持多继承么？
104、什么是值传递和引用传递？
105、是否可以在static环境中访问非static变量？
106、GC是什么? 为什么要有GC?数据结构中用于存储数据的有哪些?
107、说说hashMap是怎样实现的?
108、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
	答：short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，需要强制转换类型）
		short s1 = 1; s1 += 1;（可以正确编译）
		
109、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?
110、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?
111swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?
