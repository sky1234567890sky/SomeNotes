。l#《物联网Android 小实训练习手册》
 
#第一天v
1.	OkHttp3 配置以及GET请求，POST请求的实现思路？

	1.添加依赖
	2.创建okhttpclient对象
	3.构建request对象
	4.构建call对象
	5.发送同步或异步请求
	   Get请求:调用request对象的get()方法.
	   Post请求:调用request对象的post()方法,需要requestbody作为参数

2.	Okhttp都用了哪些设6

3.	HttpURLconnection及OkHttp3的对比分析

	1,HttpUrlConnection，google官方提供的用来访问网络，但是实现的比较简单，只支持1.0/1.1
	2,并没有多路复用，如果碰到app大量网络请求的时候，性能比较差，
	3,HttpUrlConnection底层也是用Socket来实现的
	4,OkHttp像HttpUrlConnection一样，实现了一个网络连接的过程。
	5,OkHttp和HttpUrlConnection是一级的，用socket实现了网络连接，OkHttp更强大，
	6,HttpUrlConnection在IO方面用到的是InputStream和OutputStream，但OkHttp用的是sink和source，这两个是在Okio这个开源库里的，	feredSink(支持缓冲)、GzipSink（支持Gzip压缩）、ForwardingSink和InflaterSink（后面这两者服务于GzipSink）
	7,多个相同host和port的stream可以共同使用一个socket，而RealConnection就是处理连接的，那也就是说一个RealConnection上可能有很多个Stream
	8，OkHttp代码比HttpURLConnection精简的多

4.Okhttp3的拦截器有哪些？
			网络拦截器，缓存拦截器，日志拦截器，重定向拦截器

	①一类是全局的 interceptor(程序拦截器)，该类 interceptor 在整个拦截器链中最早被调用，通过 OkHttpClient.Builder#addInterceptor(Interceptor) 传入；
	②另外一类是非网页请求的 interceptor(网络拦截器) ，这类拦截器只会在非网页请求中被调用，并且是在组装完请求之后，真正发起网络请求前被调用，所有的 interceptor 被保存在 List<Interceptor> interceptors 集合中，按照添加顺序来逐个调用，具体可参考 RealCall#getResponseWithInterceptorChain() 方法。通过 OkHttpClient.Builder#addNetworkInterceptor(Interceptor) 传入；
    
5.Retrofit2常用注解有哪些？

	@GET、@POST、@PUT、@DELETE、@HEAD @Path @Header @Query @Field
	@Part @Body @FormUrlEncoded 

6.Retrofit2发送GET、POST请求的方式？

	步骤1：添加Retrofit库的依赖 
	步骤2：创建 接收服务器返回数据 的类 
	步骤3：创建 用于描述网络请求 的接口 
	步骤4：创建 Retrofit 实例 
	步骤5：创建 网络请求接口实例 并 配置网络请求参数 
	步骤6：发送网络请求（异步 / 同步）封装了 数据转换、线程切换的操作
	步骤7： 处理服务器返回的数据

7.简单说一下Retrofit与OKHttp3的区别。

	Retrofit是Square开源的一款适用于Android网络请求的框架。
	Retrofit底层是基于OkHttp实现的，与其他网络框架不同的是，它更多使用运行时注解的方式提供功能

	OkHttp是Square开源的轻量级框架，是一款现代、高效、快速的Android版Http client。


8.Retrofit的优缺点 
	优点：
	 可以配置不同HTTP client来实现网络请求，如okhttp、httpclient等；
	 请求的方法参数注解都可以定制；
	 支持同步、异步和RxJava；
	 超级解耦；  
	 可以配置不同的反序列化工具来解析数据，如json、xml等；
	 使用非常方便灵活；
	缺点：
	 不能接触序列化实体和响应数据；
	 执行的机制太严格；
	 使用转换器比较低效；
	 只能支持简单自定义参数类型；



 
#第二天

1、Overload和Override的区别?
	Override 是重写方法方法名称、参数个数，类型，顺序，返回值类型都是必须和父类方法一致的。它的关系是父子关系
	Overload 是重载方法方法名称不变，其余的都是可以变更的。它的关系是同一个类，同一个方法名，不同的方法参数或返回值。
	备注：它们都是是Java多态性的不同表现

2、String 和StringBuffer和 StringBuilder的区别?
	String 长度不可变
	StringBuffer 长度可变,线程安全 效率高
	StringBuilder 长度可变,线程不安全 效率低

3、实现一个字符串倒序?
	.split()：将一个字符串分割为子字符串数组，然后将结果作为字符串数组返回。
	.reverse() 返回一个元素顺序被反转的 Array 对象。
	.charAt()方法可返回指定位置的字符。

4、集合的实现类与区别?

	Collection接口包括三个子接口分别为Set、Quere、List。
	List接口主要有两个实现类ArrayList、LinkedList。List接口是有序集合、元素可以重复，次序
	Set接口主要有两个实现类HashSet和TreeSet。Set是无序的、不可重复的。
    Map接口中的实现类HashMap底层是通过数组+链表实现，

5、抽象类与接口的区别（abstract与interface的区别）?
   抽象类:可以有构造;子类使用extends继承;可以有非抽象方法,方法也可以是非public的;可以继承一个类和实现多个接口
	接口:没有构造;子类使用implements实现;方法必须是抽象的,而且是public的;只可以继承一个或多个其它接口
	
	(1) 抽象基类可以定义字段、属性、方法实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段。
	(2) 抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。微软的自定义接口总是后带able字段，证明其是表述一类“我能做。。。”
	(3) 接口可以被多重实现，抽象类只能被单一继承
	(4) 抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中
	(5) 抽象类是从一系列相关对象中抽象出来的概念， 因此反映的是事物的内部共性；接口是为了满足外部调用而定义的一个功能约定， 因此反映的是事物的外部特性
	(6) 接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法    
	(7) 接口可以用于支持回调,而继承并不具备这个特点
	(8) 抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的 
	(9) 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法

6、线程有几种状态,分别是哪些?
	new(新创建),runnable(可运行),blocked(被阻塞),waiting(等待),timed waiting(计时等待),terminated(被终止)


7、final、finally、finanlize()的区别?
	(1)、final修饰符（关键字）。被final修饰的类，就意味着不能再派生出新的子类，不能作为父类而被子类继承。
	(2)、finally是在异常处理时提供finally块来执行任何清除操作。
	(3)、finalize是方法名。java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的


8、J2EE是什么？请对以下在J2EE中常用的名词进行解释(或简单描述)?
	(1)web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接**互，不必关注其它系统问题。主要有WEB服务器来实现。
	(2)EJB容器：Enterprise java bean 容器,他提供给运行在其中的组件EJB各种管理功能
	(3)JNDI：（Java Naming & Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。
	(4)JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。
	(5)JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。
	(6)JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。
	(7)RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。
	RMI是JAVA特有的。

9、J2EE常用的设计模式？说明工厂模式?
	Responsibleity（责任链模式）
	Factory（工厂模式）
	Builder（建造模式）
	Singleton（单例模式）
	Adapter（适配器模式）
	Bridge（桥梁模式）
	Observer（观察者模式）
	Strategy（策略模式）
	Command（命令模式）
	工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，
	通常这一组类有一个公共的抽象父类并且实现了相同的方法，
	但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。
	然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例B 。当得到子类的实例后，
	开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。


10、开发中都用到了那些设计模式?用在什么场合?
	设计模式很多，但总的来讲分为4大类，
	creationalpatterns，通常是隐藏对象的new进程，通过专门的类来具现对象。
	structuralpatterns，根据类的层次关系和接口来设计。
	behavioralpatterns根据对象间的通讯来设计
	J2EEpatterns.重视于表现层设计每类都有很多种。
	singleton:单例,用来减少垃圾对象和缓存用
	factory:工厂模式,用来解耦（呵呵，其实模式都是用来解耦的）
	facade和decorator:封装接口
	command:命令模式，传递
	Iterator:用来遍历对象
	Observer:用来监听状态变化（现在习惯用listener机制替代）
	templete:模板模式，用来处理相同的操作步骤
	strategy:策略模式，策略选择
	proxy:用来附加功能，属性或隐蔽。
	bridge也很实用，用来解耦工厂与产品搭配之类的选择


#第三天
1什么是面向对象以及与面向过程的区别？
面向对象，就是基于面向对象的过程不停地创建对象，调用对象，指挥对象解决问题
面向对象和面向过程的区别   就像是面向过程程序只用函数实现，而面向对象程序是用类实现各个功能模块。
	面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
	面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
	从结构上来说，面向过程的特点是模块化和流程化，而面向对象的特点是封装，继承和多态。

2、面向对象的三大特性、五大原则？
	面向对象的三大基本特征为：封装、继承、多态
	单一职责原则，开放封闭原则，里氏替换原则，依赖倒置原则，接口隔离原则。



3、对封装、继承、多态的理解？
	封装
	把客观事物抽象出来，封装成类，并且类可以把自己的属性和方法只让可信的类或者对象操作，封装可以让多个事物之前比较清晰和明了。
	继承
	继承是面向对象编程主要的功能，它可以让其他类可以使用该类的指定的方法和属性，而不用重新编写相应的代码，且可以在该类的基础下进行功能的扩展。继承也是最好理解的特征。
	多态
	一个接口，多种实现。将父对象设置成一个或多个其子对象的方式称为多态，也就是说。允许将子类类型的指针赋值给父类类型的指针。



4、Java的排序方式？
	1.冒泡排序  所谓冒泡排序就是从前到后遍历选出最大值放到最后一个，然后在遍历剩下的找出剩
	下中最大的放到倒数第二个，依次直至遍历到最后一个，也就是最小的放到第一个，使其有序。
	2.选择排序
	选择排序就是从第一趟开始，用第一个元素和剩下中的每一个元素比较，如果比第一
	个小，就和第一个元素交换值，最后使得第一个元素中的值最小，第二趟选择出第二小的放到第二元素，依次，使得数组有序。
	3.插入排序
	插入排序类似于打扑克牌，从第二张牌开始插入，小的插到大的前面，然后使其有序。再拿第三张牌来，找到合适的位置继续插入，使这三张有序。在第四张直至全部插入有序。



5、Java内存模型是什么？
	Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，它描述的是一组规则或规范，
	通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。


6、Thread 类中的start() 和 run() 方法有什么区别？
	start()只是让线程处于就绪状态。告诉CPU我已经准备好了，可以调用我了。
	而run()则是直接按顺序执行


7、Java的引用类型有哪些？
	强引用（StrongReference）
	软引用（SoftReference）
	弱引用（WeakReference）
	虚引用（PhantomReference）


8、标识符组成规则?
	1） 标识符由字母、数字、下划线“_”、美元符号“$”或者人民币符号“￥”组成，
	并且首字母不能是数字。
	2） 不能把关键字和保留字作为标识符。
	3） 标识符没有长度限制。
	4） 标识符对大小写敏感。


9、单&和双&的区别?
	单&，左边无论真假，右边都要参与运算
	双&，左边为真，右边不参与运算



10、==和equals的区别?
	基本数据类型比较时，==和Equals都比较两个值是否相等。相等为true 否则为false；
	引用对象比较时，==和Equals都是比较栈内存中的地址是否相等 。相等为true 否则为false；


11、UDP 和TCP分别是什么及其区别
	UDP ，用户数据报协议，计算机之间不必建立连接，数据打包发送，每包最多发送64K数据，因为不需要建立连接，
	所以不安全，是不可靠协议，因为不需要建立连接，所以效率高。
	TCP，传输控制协议，通过三次握手建立连接，通过IO流传输数据，对数据大小没有大小限制，因为建立好了连接，
	数据传输过
	程是安全的，是一个可靠协议，传输速度慢，效率高
	
	TCP与UDP区别总结：
	1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
	2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;
	UDP尽最大努力交付，即不保证可靠交付
	Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。
	如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
	3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
	4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
	5、TCP对系统资源要求较多，UDP对系统资源要求较少。


#第四天
1,在使用GreenDao的时候，会在Gen文件下生成的文件有什么
	BeanDao，DaoMaster，DaoSession

2.简述GreenDao配置流程
	添加代码仓库  步骤1
	greenDao生产代码插件  步骤2
	apply plugin 步骤3
	greenDAO依赖  步骤4
	设置版本号和生成源文件的路径 步骤5

3.GreenDao的常用注解，以及增删改查的方法？
	@Entity：定义实体类  
	@ID 第一主键  ..
	@Unique  设置属性唯一  
	@ToOne 一对一  
	@ToMany 一对多


4.简述GreenDao的优缺点
	1：存取速度快
	2：支持数据库加密
	3：轻量级
	4：激活实体
	5：支持缓存
	6：代码自动生成	


5谈谈你对观察者模式的理解
	观察者模式的适用范围是适合一对多情况，有一个主题，n个观察者。当主题发生变化时，相对应的观察者都会收到更新通知，从而更新自己的一些数据或触发一些行为，比如支付宝中当你消费一些钱后，很多个和支付宝余额相关的界面都会得到更新！待续！
	观察者模式的思想核心，我觉得用一个词来总结的话，就是群发！


6.Rxjava的好处？
	优点1：简化逻辑,解耦了各个模块操作，单一化		
	比如要嵌套请求的时候，这个时候用flatMap操作符就可以实现优雅的链式嵌套请求
	
	优点2：简化代码		
	它的操作符封装了规则，我们用一个操作符就可以实现许多功能
	比如要打包网络请求，这个时候用zip就可以打包数据源	
	
	优点3：操作符强大，可以实现各种功能		
	flatmap解决嵌套回调的问题；mergeWith()可以把不同异步操作合并	
	优点4：方便线程切换
	优点5：错处处理
	只要有异常发生onError()一定会被调用，这极大的简化了错误处理。只需要在一个地方处理错误即可


7.RxJava与AsyncTask的区别？
	RxJava 是一个响应式编程框架，通过一种扩展的观察者设计模式来实现异步操作。 跟AsyncTask类似，但是比AsyncTask更加简洁随着程序逻辑变得越来越复杂，它依然能够保持逻辑的简洁


8.MVP以及MVC各自之间的作用？
MVC:
	MVC是比较直观的架构模式，用户操作->View（负责接收用户的输入操作）->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）。
MVP:
	MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。


9.MVP的实现步骤？
	创建v层对应接口
	创建m层对应接口实现类
	创建p层对应接口实现类 关联m、v层
	实现v层接口、调用p层方法获取回调数据


10.MVP优缺点？
	优点：
	(1)降低耦合度
	(2)模块职责划分明显
	(3)利于测试驱动开发
	(4)代码复用 
	(5)隐藏数据
	(6)代码灵活性
	缺点：由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。还有一点需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了


#第五天
1、List、ArrayList、LinkedList底层分别什么实现的?
	List接口主要有两个实现类ArrayList、LinkedList
	ArrayList：底层数据结构使数组结构，查询速度快，增删改慢，
	LinkList：底层使用链表结构，增删速度快，查询稍慢

2、Get和post区别?
	get请求地址栏会携带提交数据，post不会携带，数据携带到请求体里面
	get请求安全级别较低，post较高
	get请求有数据大小的限制，post没有限制


3、网络通信三要素分别是什么及其作用?
	a.IP:IP地址是每台计算机或者设备在网络上的标识
	b.端口号:操作系统给每一个网络程序分配的一个号码(0-65535),这个号码是惟一的,不能重复
	网络程序与程序之间,就是通过端口号来识别的系统保留部分(0-1024)	
	c.传输协议	要想数据发送与接收能够配合默契,必须使用相同的协议常见的网络协议:UDP TCP
	通信过程:通过IP地址,找到相应的计算机,在通过端口号找到需要使用的程序,这个时候就可以实现网络通信了!



4、简述如何的实现多线程?
	1）定义一个类，继承自Thread类
		实现Thread的run（）方法，在run（）方法中完成我们想要处理的工作，调用start（）方法开启线程
	2）通过实现Runnable接口的方式实现
		定义Task类实现Runnable接口，定义测试类，开启线程	


5、说出Servlet的生命周期，并说出Servlet和CGI的区别?
	实例化：Servlet容器创建Servlet类的实例。
	初始化：该容器调用init()方法，通常会申请资源。
	服务：由容器调用service()方法，（也就是doGet()和doPost()）。
	破坏（离去）：在释放Servlet实例之前调用destroy()方法，通常会释放资源。
	不可用：释放内存的实例。
	CGI（Common Gateway Interface通用网关接口）程序来实现数据在Web上的传输，使用的是如Perl这样的语言编写的，它对于客户端作出的每个请求，必须创建CGI程序的一个新实例，这样占用大量的内存资源。由此才引入了Servlet技术。
	Servlet是一个用java编写的应用程序，在服务器上运行，处理请求信息并将其发送到客户端。对于客户端的请求，只需要创建Servlet的实例一次，因此节省了大量的内存资源。Servlet在初始化后就保留在内存中，因此每次作出请求时无需加载。

6、同步和异步有何异同，在什么情况下分别使用他们？举例说明?
	如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
	
	当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。



7、heap和stack有什么区别?
	1). 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方
	2). 栈的优势是，存取速度比堆要快;堆的优势是可以动态地分配内存大小，
	3)每个JVM的线程都有自己的私有的栈空间，随线程创建而创建
	java的heap是所有线程共享的，堆存放所有 runtime data ，里面是所有的对象实例和数组，heap是JVM启动时创建



8、forward和redirect的区别?
	（1）地址栏：forward为服务器的直接跳转，客户端浏览器并不知道，地址栏内容不变（服务器内部的动作）redirect为客户端浏览器根据URL地址重新向服务器请求，地址栏变（有可能是请求的URI地址发生变化）
	（2）数据共享：forward共享浏览器传来的request    redirect全新的request
	（3）运用的地方：forward用户登录后根据角色跳转页面 redirect在用户注销后跳转主页或其他页面
	（4）效率：forward比redirect少了一次服务器请求，效率高一些


9、说出数据连接池的工作机制是什么 ?
	J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，
	池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。
	当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。



10、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢 ?
	equals（）



#第六天
1、两个对象值相同(x.equals(y) == true)?
	是对的，关键看你如何去实现hashCode（）和equals（）方法


2、重写equals()方法的时候，我们还需要重写哪个方法？为什么?
	hashCode（）
	String类的源码：可以发现String是重写了Object类的equals方法的，并且也重写了hashcode方法


3、当一个对象被当作参数传递到一个方法后?
	Java编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象,对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。


4、java中有几种方法可以实现一个线程?
	继承Thread类，实现run（）方法
	实现Runnable接口，实现run（）方法
	实现Callable<T>接口，重写call函数



5、java 是如何分配内存的 ， java的内存管理  ？ 
	内存分配：
	内存区域分为6块：堆区，方法区，运行时常量池，虚拟机栈，本地方法栈，PC寄存器
	
	内存管理：
	包括两方面：内存分配（创建Java对象的时候）和内存回收	


6、线程池的理解?
	如果开发的线程数据很多，并且每个线程都是执行一个时间很短的任务就结束了。这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。
	那么有什么办法可以使的线程多次被复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在java中可以通过线程池来达到这样的效果。

7、HashMap和LinkedHashMap的区别?
	HashMap ：根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度
	LinkedHashMap：内部维持了一个双向链表,221121可以保持顺序



8、Error和Exception有什么区别？
	Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
	
	Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。


9、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？
	throws是获取异常
	throw是抛出异常
	try是将会发生异常的语句括起来，从而进行异常的处理，catch是如果有异常就会执行他里面的语句，而finally不论是否有异常都会进行执行的语句。



10、运行时异常与受检异常有何异同？
	运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。


#第七天
1、Collection和Collections的区别？
	Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。
	Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。


2、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?
	sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，
	将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复
	wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lockpool），如果线程重新获得对象的锁就可以进入就绪状态


3、线程的sleep()方法和yield()方法有什么区别？
	① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
	② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
	③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
	④ sleep()方法比yield()nnnnnn方法（跟操作系统CPU调度相关）具有更好的可移植性。


4、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？
     是不能的,其他线程只能访问该对象的非同步方法,同步方法则不能进入;
     因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁,如果已经进入A方法,说明对象锁已经被取走了,那么试图进入B方法的线程就只能在等锁池(注意这里不是等待池)中等待对象的锁


5、请说出与线程同步以及线程调度相关的方法?
	wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
	- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；
	- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
	- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；


6、synchronized关键字的用法？
	指定对象加锁:对给定的对象进行加锁,进入同步代码块要获得给定对象的锁
	直接作用于实例方法:相当于对当前实例加锁,进入同步代码块要获得当前实例的锁(这要求创建Thread的时候,要用同一个Runnable的实例才可以)
	直接作用于静态方法:相当于给当前类加锁,进入同步代码块前要获得当前类的锁


7、启动一个线程是调用run()还是start()方法？
	start()


8、简述synchronized 和java.util.concurrent.locks.Lock的异同？
	1.Lock能完成几乎所有synchronized的功能，并有一些后者不具备的功能，如锁投票、定时锁等候、可中断锁等候等
	2.synchronized 是Java 语言层面的，是内置的关键字；Lock 则是JDK 5中出现的一个包，在使用时，synchronized 同步的代码块可以由JVM自动释放；Lock 需要程序员在finally块中手工释放，如果不释放，可能会引起难以预料的后果（在多线程环境中）。

9、Java中如何实现序列化，有什么意义？
	1.实现序列化:
	1)让类实现Serializable接口,该接口是一个标志性接口,标注该类对象是可被序列
	2)然后使用一个输出流来构造一个对象输出流并通过writeObect(Obejct)方法就可以将实现对象写出
	3)如果需要反序列化,则可以用一个输入流建立对象输入流,然后通过readObeject方法从流中读取对象
	
	2.作用:
	1)序列化就是一种用来处理对象流的机制,所谓对象流也就是将对象的内容进行流化,可以对流化后的对象进行读写操作,也可以将流化后的对象传输与网络之间;
	2)为了解决对象流读写操作时可能引发的问题(如果不进行序列化,可能会存在数据乱序的问题)
	3）序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆

10、可传递性有三个线程T1，T2，T3，怎么确保它们按顺序执行？
1.使用join
     thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。

	t.join();      //调用join方法，等待线程t执行完毕
	t.join(1000);  //等待 t 线程，等待时间是1000毫秒。

2.使用CountDownLatch（b闭锁）
3.CachedThreadPool
4.使用blockingQueue（阻塞队列）
5.使用单个线程池



#第八天
1.简述Glide以及Fresco的使用，已经常用方法？
	Glide使用：添加依赖，直接使用初始化方法，bitmap操作
	Glide.with(context).load("image src url").into(ImageView);
	Fresco使用：结合Picasso、Glide优点，更适用于加载大量图片。另支持渐进式显示图片、WebP格式图片。

2.简述Glide以及Fresco图片缓存
	Fresco ：三级缓存，分别是 Bitmap缓存，未解码图片缓存， 文件缓存。缓存的时候，只会缓存原始图像
	Glide ：只有内存和磁盘缓存，Glide会根据ImageView控件尺寸获得对应的大小的bitmap来展示


3.简述BitmapFactory类，以及图片二次采样？
	1.BitmapFactory类
	BitmapFactory是一个创建Bitmap的工具类，为我们提供了从文件、流、byte数组中创建Bitmap 对象。常用如下方法。
	
	2.图片的二次采样
	1.第一次采样
	第一次采样主要是要获得图片的压缩比例，假如说我有一张图片是200200，那么把这张图片的缩略图显示在一个5050的ImageView上，那我的压缩比例应该为4，那么这个4应该怎么样来获得呢？ 先加载图片的边界到内存中，这个加载操作并不会耗费多少内存，加载到内存之后，我就可以获得这张图片的宽高参数，然后根据图片的宽高，再结合控件的宽高计算出缩放比例。


4.简述Matrix、ColorMatrix+的作用以及使用？
	Matrix：Matrix不是用于处理颜色的，而是处理图形的。他是一个3*3的矩阵。
	colorMatrix：android中的ColorMatrix是一个4*5的数字矩阵，它          用来对图片的色彩进行处理，对于每个像素点，都有一个ColorMatrix用来保存颜色的RGBA值。

5.简述圆角和圆形图片的制作思路？
	Glide:需要自己实现圆角继承自BitmapTransformation操作bitmap对象实现
	Fresco：通过RoundingParans设置参数


#第九天
1.网络数据的三次握手 Socket 的理解 ？
	第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入SYN_SEND状态等待服务器确认
	第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
	第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手



2、Socket是如何建立连接的并进行数据传递的？
	通过三次握手 建立连接 并实现数据的传递


3、为什么说https协议是安全的？
	https本身是以安全为目标的加密http通道，https是基于SSL为基础的加密传输，传输的信息是经过加密的，所以是安全的，而http是明文传输。再帮你区别一下http和https的区别吧。
	1、https需要到ca申请证书，免费的证书很少，所以通常是需要付费的。
	2、http是超文本传输协议，传输的信息是明文信息，不经过加密，而 https是经过SSL加密的加密信息传输。 
	3、http和https的连接方式也不相同，所用端口也不一样，http的端口是80，https的端口是443.
	4、http的连接是简单的无状态连接，而https是由http+ssl构建的可进行加密的、身份验证的网络网络协议。所以更安全


4、什么是分布式垃圾回收(DGC)？它是如何工作的？
	1，	分布式垃圾回收(DGC)：
	2，	概念： 1)Java虚拟机中，一个远程对象不仅会被本地虚拟机内的变量引用，还会被远程引用。
	3，	2)只有当一个远程对象不受到任何本地引用和远程引用，这个远程对象才会结束生命周期。
	4，	说明：
	5，	1)服务端的一个远程对象在3个地方被引用：
	6，	1>服务端的一个本地对象持有它的本地引用
	7，	2>服务端的远程对象已经注册到rmiregistry注册表中，也就是说， rmiregistry注册表持有它的远程引用。
	8，	3>客户端获得远程对象的存根对象，也就是说，客户端持有它的远程引用。
	9，	2)服务端判断客户端是否持有远程对象引用的方法：
	10，	1>当客户端获得一个服务端的远程对象的存根时，就会向服务器发送一条租约(lease)通知，以告诉服务器自己持有了这个远程对象的引用了。
	11，	2>客户端定期地向服务器发送租约通知，以保证服务器始终都知道客户端一直持有着远程对象的引用。
	12，	3>租约是有期限的，如果租约到期了，服务器则认为客户端已经不再持有远程对象的引用了。
5、抽象类、抽象方法、抽象类的特点?
	一、使用abstract修饰符修饰的类被称为抽象类；

			抽象类不能实例化对象，只能被继承；

	二、使用abstract修饰符修饰的方法被称为抽象方法；

			抽象方法不能有方法体，子类必须重写抽象类中所有的抽象方 法；

	三、抽象类中不一定包含抽象方法，但包含抽象方法的类一定是抽象类；
6、ArrayList集合 、LinkedList特点?
	1.arrrayList 底层是数组实现的，查询快 ， 增删慢。
	2.Linkedlist 底层是由链表实现的， 查询慢，增删快 。

8、异常：编译时异常，运行时异常的处理方法?
	异常他是一个事件，发生在程序运行期间， 干扰了正常的指令流程
	异常可以被程序本身处理 ，而错误无法处理

	编译时异常：
	程序本身是真确的，但是因为外在的环境条件不满足引发 ，java编译器强制要求处理这类异常，一般会进行捕捉 ， ，如果不捕捉，程序将不能被编译
	运行时异常：
	意味着程序存在着bug,这类异常需要更改程序来避免，java编译器强制要求处理这类异常


9、饿汉式和懒汉式的区别?
	1、饿汉式是线程安全的,在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。懒汉式如果在创建实例对象时不加上synchronized则会导致对对象的访问不是线程安全的。

	2、从实现方式来讲他们最大的区别就是懒汉式是延时加载,他是在需要的时候才创建对象,而饿汉式在虚拟机启动的时候就会创建，饿汉式无需关注多线程问题，写法简单明了，能用则用。但是它是加载类时创建实例。所以如果是一个工厂模式，缓存了很多实例，那么就得考虑效率问题，因为这个类一加载则把所有实例不管用不用一块创建。

	3、两者建立单例对象的时间不同。“懒汉式”是在你真正用到的时候才去建这个单例对象，“饿汉式”是在不管用不用得上，一开始就建立这个单例对象。

10、session是什么？它用来干什么？解决什么问题？

	Session：在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。
	这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，
	而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。

	它可以将用户正确登录后的信息记录到服务器的内存中，当用户以此身份
	访问网站的管理后台时，无需再次登录即可得到身份确认。而没有正确登录的用户则不分配session空间，即便输入了
	管理后台的访问地址也不能看到页面内容。通过session确定了用户对页面的操作权限。

11.C/S和C/B结构 

	1.C/S（客户端/服务器模式）：
	客户端和服务器都是独立的计算机，客户端是面向最终用户的应用程序或一些接口设备，服务器是连入网络的计算机，负责向其他计算机提供各种网络服务。
	2.B/S（浏览器/服务器模式）：
	是一种网络结构模式，将系统大部分的逻辑功能集中到服务器上，客户端只实现极少的事务逻辑，使系统的开发和维护都更简洁。
	3.两者比较：
	（1）C/S是建立在局域网上的，B/S是建立在广域网上的
	（2）C/S的软件重用性没有B/S的好
	（3）C/S结构的系统的升级困难，要实现升级可能要重新实现一个系统，B/S结构中可以实现系统的无缝升级，降低维护的开销，升级简单
	（4）B/S结构使用浏览器作为展示的界面，表现的更加丰富，C/S的表现有局限性
	（5）C/S结构和操作系统相关，B/S结构可以面向不同的用户群，与操作系统的关系较小。

#第十天
1、http和https的区别？

	1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
	2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
	3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
	4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安	全。

2、常见的请求头？

	Accept	可接受的响应内容类型（Content-Types）。
	Accept-Encoding	可接受的响应内容的编码方式。
	Authorization	用于表示HTTP协议中需要认证资源的认证信息
	Connection	客户端（浏览器）想要优先使用的连接类型
	Cookie	由之前服务器通过Set-Cookie（见下文）设置的一个HTTP协议Cookie
	Content-Type	请求体的MIME类型 （用于POST和PUT请求中）
	Date	发送该消息的日期和时间（以RFC 7231中定义的"HTTP日期"格式来发送）
	Host	表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。
	Origin	发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。
	User-Agent	浏览器的身份标识字符串
	Warning	一个一般性的警告，表示在实体内容体中可能存在错误。

3、即时通讯的实现基于什么协议来实现的？
	基于TCP和UDP协议实现的一个即时通讯工具，
	具体功能包括： 工具包括服务器端和客户端； 
		具备用户注册、登录、找回密码功能（基于TCP协议）； 两个用户如果同时在线，采用点到点通信方式进行聊天，信息不需要通过服务器中转，服务器也不保存（基于TCP协议）； 
		支持离线消息（基于TCP协议）； 支持点到点


4、http协议处于网络的哪一层？
	因为HTTP协议被封装在TCP包中，使用端口号80，因此HTTP协议属于传输层之上，即应用层。


5、Delete、put、head这些请?
	GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源。
	HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。
	PUT：这个方法比较少见。HTML表单也不支持这个。
		本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，
		PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。
	DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。
	POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。
	OPTIONS：这个方法很有趣，但极少使用。
		它用于获取当前URL所支持的方法。
		若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。


6、String类的特点？
	1.String类对象的相等判断使用equals() 方法完成，“==”实现的是地址数值的比较。 
	2.字符串内容一旦声明则不可改变，String类对象内容的改变是依靠引用关系的变更实现的。 
	3.String类有两种实例化方式，使用直接赋值可以不产生垃圾空间，并且可以自动入池，不要使用构造方法完成。
7.equals()方法和equalsIgnoreCase()方法的区别?

	equals:区分大小写判断String字符串
	equalsIgnoreCase:不区分大小写判断String字符串。


8.isEmpty()方法的作用?
	判断该字符串是否为空
	isEmpty() 方法当 String.length() 为 0 时返回 true

9.HashSet如何保证元素唯一性?

	因为HashSet()保证元素唯一性是通过元素的两个方法，hashCode()和equals()来完成的。 
	如果元素的HashCode值相同，才会调用equals判断是否为true。 
	如果元素的HashCode值不同，不会调用equals。
10、LinkedHashSet类的特点?
	底层是使用了链表数据结构实现的；特点：查询速度慢，增删快；
	1、去掉重复元素

	2、具备先进先出的特点
11、Iterator 相关方法和注意事项?
	(1) 使用方法iterator()要求容器返回一个Iterator。
	(2) 使用next()获得序列中的下一个元素。
	(3) 使用hasNext()检查序列中是否还有元素。
	(4) 使用remove()将迭代器新返回的元素删除。

	注意事项：但是在使用的时候需要注意的是，如果在遍历的过程中增加元素、删除元素等改变了List、HashMap之类的List的结构时，会产生ConcurrentModificationException（并发修改）异常。


#第十一天
1、集合类的特点?

	Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变；
	List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变；
	Map：适合储存键值对的数据。


2、什么是进程？

	进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.


3、I/O流？

I/O流的分类：
	流向：输入流 是读取数据的
	输出流 是写入数据的
	数据类型：
	字节流
	字节输入流 读取数据 InputStream
	字节数出流 写入数据 OutputStream
	字符流：
	字符输入流，读取数据 Reader
	字符输出流，写入数据 Writer

4、数组和链表的异同？

	数组和链表的区别
	二者都属于一种数据结构
	从逻辑结构来看
	1. 数组申请的是一块连续的内存空间，编译阶段就确定了空间大小，运行阶段是不允许改变的，不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数，造成数据越界；当数据减少时，造成内存浪费；
	2. 链表动态地进行存储分配，现用现申请，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项，非常繁琐）链表必须根据next指针找到下一个元素。
	从内存存储来看
	1. (静态)数组从栈中分配空间, 对于程序员方便快速,但是自由度小，数组可以根据下标直接存出数据。如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。
	2. 链表从堆中分配空间, 自由度大但是申请管理比较麻烦 ，链表是物理上非连续的内存空间，对于访问数据，需要从头便利整个链表直到找到要访问的数据，没有数组有效，但是在添加和删除数据方面，只需要知道操作位置的指针，很方便可以实现增删，较数组比较灵活有效率。



5、线程和进程有什么区别？
	（1）线程是CPU独立运行和独立调度的基本单位；
	（2）进程是资源分配的基本单位；
	两者的联系：进程和线程都是操作系统所运行的程序运行的基本单元。
	区别：
	（1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。
	（2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。


6、如何实现线程?
（1）定义一个类，继承自Thread类
	实现Thread的run（）方法，在run（）方法中完成我们想要处理的工作，调用start（）方法开启线程
（2）通过实现Runnable接口的方式实现
	定义Task类实现Runnable接口，定义测试类，开启线程



7、使用多线程的优缺点？
	坏处：增加了调度和管理的开销，带来了一些不确定性，需要复杂的同步机制，避免死锁等等。
	好处：一定程度上提高响应速度，在多核的情况下还是更能充分利用CPU资源的。



8、怎么判断服务端返回的数据类型?
	除了动态判断收到的数据类型,也可以使用binaryType属性,显式指定.


9、栈，队列代码?
栈类，实现了入栈、出战、获取栈顶元素以及判空的操作：

	 1 package cn.wzbrilliant.datastructure;
	 2 
	 3 /**
	 4  * 栈
	 5  * @author ice
	 6  *
	 7  */
	 8 public class Stack {
	 9     private int size;
	10     private Node top;
	11 
	12     public Stack() {
	13         size = 0;
	14         top = null;
	15     }
	16 
	17     public void push(Node node) {
	18         node.setNext(top);
	19         top = node;
	20         size++;
	21     }
	22 
	23     public Node pop() {
	24         if (top == null)
	25             return null;
	26         Node node = top;
	27         top = top.getNext();
	28         size--;
	29         return node;
	30     }
	31 
	32     public Node top() {
	33         return top;
	34     }
	35 
	36     public int size() {
	37         return size;
	38     }
	39 
	40     public boolean isEmpty() {
	41         if (size == 0)
	42             return true;
	43         return false;
	44     }
	45 }

 

队列类，实现了入队、出队、判空的操作：


	 1 package cn.wzbrilliant.datastructure;
	 2 
	 3 /**
	 4  * 队列
	 5  * @author ice
	 6  *
	 7  */
	 8 public class Queue {
	 9 
	10     private Node head;
	11     private Node tail;
	12     private int size;
	13 
	14     public Queue() {
	15         this.head = null;
	16         this.tail = null;
	17         this.size = 0;
	18     }
	19 
	20     public void enQueue(Node node) {
	21         tail.setNext(node);
	22         tail = node;
	23         size++;
	24     }
	25 
	26     public Node deQueue() {
	27         if (size == 0)
	28             return null;
	29         Node node = head;
	30         head = head.getNext();
	31         size--;
	32         return node;
	33     }
	34 
	35     public int size() {
	36         return size;
	37     }
	38 
	39     public boolean isEmpty() {
	40         if (size == 0)
	41             return true;
	42         return false;
	43     }
	44 
	45 }



10、java常用的处理异常的机制，原理及应用?
Java中的异常处理机制的简单原理和应用 :

java中Throwable这个类可以被作为异常抛出的类,继承它的分为异常Exception和错误Error.

Exception表示程序需要捕捉和处理的的异常;

Error表示系统级别的错误和程序无需处理的。

	我们所需要关心的是Exception. Execption可以分为java标准定义的异常和程序员自定义异常2种.

	（1）一种是当程序违反了java语规则的时候,JAVA虚拟机就会将发生的错误表示为一个异常.这里语法规则指的是JAVA类库内置的语义检查。

	（2）另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是Thowable的子类。

异常处理是与程序执行是并行的.


#第十二天
1、Java中操作字符串使用哪个类？
	String，StringBuffer，StringBuilder


2、String类的常用方法有那些？
	charAt：返回指定索引处的字符
	indexOf()：返回指定字符的索引
	replace()：字符串替换
	trim()：去除字符串两端空白
	split()：分割字符串，返回一个分割后的字符串数组
	getBytes()：返回字符串的byte类型数组
	length()：返回字符串长度
	toLowerCase()：将字符串转成小写字母
	toUpperCase()：将字符串转成大写字符
	substring()：截取字符串
	format()：格式化字符串
	equals()：字符串比较


3、判断两个对象是否相同，能使用equlas比较吗？

	不能。Equlas大多用来做字符串比较，要判断基本数据类型或者对象类型，需要使用==


4、Java中的继承是单继承还是多继承?

	Java中既有单继承，又有多继承。对于java类来说只能有一个父类，对于接口来说可以同时继承多个接口


5、super与this表示什么？
	Super表示当前类的父类对象
	This表示当前类的对象

6、接口有什么特点？
	接口中声明全是public static final修饰的常量
	接口中所有方法都是抽象方法
	接口是没有构造方法的
	接口也不能直接实例化
	接口可以多继承


7、Java中异常分为哪两种？

	编译时异常
	运行时异常


8、Array与ArrayList有什么不一样？
	
	Array与ArrayList都是用来存储数据的集合。ArrayList底层是使用数组实现的，但是arrayList对数组进行了封装和功能扩展，拥有许多原生数组没有的一些功能。我们可以理解成ArrayList是Array的一个升级版。


9、常用io类有那些？
	File
	FileInputSteam，FileOutputStream
	BufferInputStream，BufferedOutputSream
	PrintWrite
	FileReader，FileWriter
	BufferReader，BufferedWriter
	ObjectInputStream，ObjectOutputSream


10、线程同步的方法?
	wait():让线程等待。将线程存储到一个线程池中。
	notify()：唤醒被等待的线程。通常都唤醒线程池中的第一个。让被唤醒的线程处于临时阻塞状态。
	notifyAll(): 唤醒所有的等待线程。将线程池中的所有线程都唤醒。



11、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
	java虚拟机，运用硬件或软件手段实现的虚拟的计算机。
	因为不同的平台装有不同的JVM，它们能够将相同的.class文件，解释成不同平台所需要的机器码。	正是因为有JVM的存在，java被称为平台无关的编程语言
